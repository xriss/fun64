<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Title</title>
  <id>/blog/feed.xml</id>
  <updated>2017-03-19T00:00:00.000Z</updated>
  <link rel="self" type="application/atom+xml" href="/blog/feed.xml"/>
  <link rel="alternate" type="application/json" href="/blog/feed.json"/>
  <link rel="alternate" type="text/html" href="/"/>
  <generator uri="https://github.com/bcomnes/jsonfeed-to-atom#readme" version="1.1.3">jsonfeed-to-atom</generator>
  <entry>
    <id>/blog/2017-03-19-chatdown</id>
    <title>Chatdown</title>
    <updated>2017-03-19T00:00:00.000Z</updated>
    <published>2017-03-19T00:00:00.000Z</published>
    <author>
      <name>xriss</name>
    </author>
    <content type="html">
      <![CDATA[<a href="/blog/2017-03-19-chatdown" class="blog_post_link">
	<span class="blog_post_title">Chatdown</span>
	<span class="blog_post_snip"><p>Chatdown is  a markdown like text format for describing chat trees, the 
idea is to have all the logic somewhere else and just use this for 
describing the relationship and hierarchy of the text.</p>
<p>The bad news is this means you have to label each part of the chat with 
reasonable ids so the code can find it. Naming things is hard and has
to be done.</p>
<p>Mostly the file is interpreted as paragraphs similar to markdowns 
paragraphs separated by empty lines, between these paragraphs lines 
beginning with one of the special characters #&lt;&gt;= switch the mode, and 
assign where the next set of paragraphs will be stored.</p>
<p>Following immediately on from these special characters with no white 
space in between are the id labels, these are used to name each set of 
paragraphs and allow references between them. This is the most complex 
part of the chatdown format.</p>
<p>A chat is started by beginning a line with a # this can be thought of 
as the talky part of an NPCs brain and a chatdown file contains 
multiple chats. These chats can reference each other, for example one 
NPC can check what you have told another NPC.</p>
<p>The first paragraph of a #chat is the display name of the NPC, the rest 
of the paragraphs are a longer description. More data can also be 
associated with the NPC here but I will go into that another time.</p>
<p>Responses are started with a &lt; and they belong to the current chat, 
these are the things that an NPC says, for instance, &lt;welcome is the 
first thing an NPC says when you talk to them.</p>
<p>Decisions are your choices that can be made after an NPC talks, started 
with a &gt; these are stored in the current response and are primarily 
links to another response.</p>
<p>With decisions the first paragraph is displayed and the remaining 
paragraphs can be used as the spoken out loud dialogue. Some styles of 
dialogue writing use this form, others only need the first paragraph.</p>
<p>Proxies are variables associated with this chat, they are assigned by 
lines beginning with an = and all paragraphs following are given to 
this proxy. Proxies way be set inside any of the other states and the 
change will happen as you progress through the chat. This allows us to 
track decisions by changing a proxy inside the decision.</p>
<p>Proxies may be expanded inside paragraphs or even option names by using 
squiggly brackets like so {proxyname}, more complicated expansions will 
be added later if needed.</p>
<p>This is just an overview and its best we explain with some code, so 
take a look at the following chatdown example which you will find 
embedded at the top of this fun64 file. The code to parse and display 
this format is included, probably best you do not look too closely at 
that bit :)</p>
<p>Since chatdown took some time to formalise, it is also going to take 
more than one short post to explain, expect a follow up with a more 
complex example.</p>
</span>
	<span class="blog_post_user">
		<span>~ xriss</span>
		<span><i>2017-03-19</i></span>
	</span>
</a>

]]>
    </content>
    <link rel="alternate" href="/blog/2017-03-19-chatdown"/>
  </entry>
  <entry>
    <id>/blog/2017-02-12-hello-world</id>
    <title>Hello World!</title>
    <updated>2017-02-12T00:00:00.000Z</updated>
    <published>2017-02-12T00:00:00.000Z</published>
    <author>
      <name>xriss</name>
    </author>
    <content type="html">
      <![CDATA[<a href="/blog/2017-02-12-hello-world" class="blog_post_link">
	<span class="blog_post_title">Hello World!</span>
	<span class="blog_post_snip"><p>Apparently if your hello world example is longer than a couple of lines 
then you are open to ridicule.</p>
<p>I suspect people who say this are blissfully unaware exactly what _main 
gets up to before your code runs and lets not even think about C++.</p>
<p>Still it helps to remove as much gubbins as possible so the code that&#39;s 
running becomes obvious. Fun64 is built around the idea that you should 
define the hardware before the program runs so lets hide all that away 
inside a builtin function that will set you up a basic looking screen 
to work with.</p>
<p>Introducing the configurator, this function will provide various setups 
depending on the mode requested and also provide a main function that 
will allow you to provide a single update function rather than dealing 
with more complexities. A single update function is less optimal but a 
perfectly reasonable way to write short bits of test code.</p>
<p>So far the only mode we have is &quot;fun64&quot; which will get you a 60fps 
320x240 screen with three layers and the Swanky32 palette. The three 
layers gives us a copper background, a tile+sprite foreground and 
finally a text overlay on the very top. For graphical memory we have a 
64x64 area of 8x8 tiles (4096 in total) and we auto upload the 4x8 
fun64 font to the very first line for use by the text layer.</p>
<p>NB: If you clobber this top line all your text will go funny, just like 
on real hardware.</p>
<p>The main point of the layers is so we can have drop shadows between 
them, the text layer on top gives us some very cheap 80s looking text 
menus when used with solid blocks of background color.</p>
</span>
	<span class="blog_post_user">
		<span>~ xriss</span>
		<span><i>2017-02-12</i></span>
	</span>
</a>

]]>
    </content>
    <link rel="alternate" href="/blog/2017-02-12-hello-world"/>
  </entry>
  <entry>
    <id>/blog/2017-01-27-comic-test</id>
    <title>Comic test.</title>
    <updated>2017-01-27T00:00:00.000Z</updated>
    <published>2017-01-27T00:00:00.000Z</published>
    <author>
      <name>xriss</name>
    </author>
    <content type="html">
      <![CDATA[<a href="/blog/2017-01-27-comic-test" class="blog_post_link">
	<span class="blog_post_title">Comic test.</span>
	<span class="blog_post_snip"><p>Lets see if we can build 4lfa.com style comics using just fun64 :)</p>
</span>
	<span class="blog_post_user">
		<span>~ xriss</span>
		<span><i>2017-01-27</i></span>
	</span>
</a>

]]>
    </content>
    <link rel="alternate" href="/blog/2017-01-27-comic-test"/>
  </entry>
  <entry>
    <id>/blog/2017-01-20-basic-fun</id>
    <title>Basic fun!</title>
    <updated>2017-01-20T00:00:00.000Z</updated>
    <published>2017-01-20T00:00:00.000Z</published>
    <author>
      <name>xriss</name>
    </author>
    <content type="html">
      <![CDATA[<a href="/blog/2017-01-20-basic-fun" class="blog_post_link">
	<span class="blog_post_title">Basic fun!</span>
	<span class="blog_post_snip"><p>A cut down and basic fun example, we do not make many assumptions so 
you are free to configure and setup your code to your own tastes.</p>
<p>There are only two parts that you must provide for fun to work. The 
first is a table describing the virtual hardware component setup, eg 
the resolution of screen and tilemaps and sprite layers to display.</p>
<pre><code>hardware={
    {
        component=&quot;screen&quot;,
        size={424,240}, -- lowrez with a 1920x1080 aspect
        scale=3, -- draw in a window at 3 times scale
        fps=60, -- 60 fps please
    },
    ...
}</code></pre><p>This requests the virtual hardware that will be setup before main is 
called. system is a global table that will be created according to your 
requested hardware and can then be referenced when the main function is 
called.</p>
<p>The second is a main function which will be called as a yield-able 
co-routine with a table that should be treated as an incoming message. 
Use the basic skeleton below to receive need.setup/update/draw 
requests. As you can see it is possible to have multiple needs at once 
and this call structure allows for a setup, repeat update/draw then cleanup 
flow of code within this co-routine.</p>
<pre><code>function main(need)
    if not need.setup then need=coroutine.yield() end -- wait for setup request

    -- perform setup

    local done=false while not done do
        need=coroutine.yield()

        if need.update then

            -- perform update

        end

        if need.draw then

            -- perform draw

        end            

        if need.clean then done=true end -- cleanup requested
    end

    -- perform cleanup

end</code></pre></span>
	<span class="blog_post_user">
		<span>~ xriss</span>
		<span><i>2017-01-20</i></span>
	</span>
</a>

]]>
    </content>
    <link rel="alternate" href="/blog/2017-01-20-basic-fun"/>
  </entry>
</feed>